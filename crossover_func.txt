@ti.func
def TSP_random_length_crossover(parent1, parent2):
	start = randint(1, NUM_CITIES-3)
	end = randint(start, NUM_CITIES-2)

	offspring1_genome = ti.Vector([-1 for _ in range(NUM_CITIES)], dt=ti.i32)
	offspring2_genome = ti.Vector([-1 for _ in range(NUM_CITIES)], dt=ti.i32)

	for i in range(start, end+1):
		offspring1_genome[i] = parent1.genome[i]
		offspring2_genome[i] = parent2.genome[i]

	parent1_pointer = end + 1
	parent2_pointer = end + 1
	# There's a more efficient way to do this I'm sure
	pointer = end + 1
	count = end-start+1
	while count < NUM_CITIES:
		gene_found = 0
		for i in range(NUM_CITIES):
			if(offspring1_genome[i] == parent2.genome[parent2_pointer]):
				gene_found = 1
				break

		if not gene_found:
			offspring1_genome[pointer % NUM_CITIES] = parent2.genome[parent2_pointer]
			count += 1
			pointer += 1
		parent2_pointer = (parent2_pointer + 1) % NUM_CITIES

	pointer = end+1
	count = end-start+1
	while count < NUM_CITIES:				
		gene_found = 0
		for i in range(NUM_CITIES):
			if(offspring2_genome[i] == parent1.genome[parent1_pointer]):				
				gene_found = 1
				break

		if not gene_found:			
			offspring2_genome[pointer % NUM_CITIES] = parent1.genome[parent1_pointer]
			count += 1
			pointer += 1
		parent1_pointer = (parent1_pointer + 1) % NUM_CITIES  
	
	return offspring1_genome, offspring2_genome


@ti.kernel
def test_crossover():
	individual1 = Individual()
	individual1_genome = ti.Vector([(i+1) for i in range(NUM_CITIES)])
	individual1.initialize_with_genome(individual1_genome)

	individual2 = Individual()
	individual2_genome = ti.Vector([(NUM_CITIES) - i for i in range(NUM_CITIES)])
	individual2.initialize_with_genome(individual2_genome)

	print(individual1.genome)
	print(individual2.genome)
	print("performing crossover")
	print(TSP_random_length_crossover(individual1, individual2))
